Auth Service
ðŸŽ¯ Goals

Handle authentication securely

Issue and validate JWT tokens

Keep identity separate from business logic

ðŸ“Œ Responsibilities

User registration

User login

Token generation & validation

ðŸš« Out of Scope

Location handling

Search logic

Product logic

ðŸ› ï¸ Steps

Register user with email & password

Hash password before storage

Issue JWT with userId and role

Validate JWT on protected routes

2ï¸âƒ£ User Service
ðŸŽ¯ Goals

Manage user identity & roles

Store static user/vendor location

Act as source of truth for user metadata

ðŸ“Œ Responsibilities

User profile management

Role assignment (CONSUMER / VENDOR)

Location storage & update

Vendor trust metadata (not logic)

ðŸš« Out of Scope

Product CRUD

Geo search

Rating calculations

ðŸ› ï¸ Steps

Create user profile on signup

Allow role update (user â†’ vendor)

Accept manual location update

Store location using GeoJSON

Expose user DTOs only


request dto =except id every details
responsedto= except regisgtration date everything

controller (requestdto)--> service
service (requestdto) --> mapper(model(entity)) id auto genrate === save to repository

while returning
mapper(entity or model) --> responsedto

tomodel me entiy me save hota hai through request
todto me ressponsedto me save hota hai through entity



private final PatientService patientService;   // this is called constructor injection

    public PatientController(PatientService patientService) {
        this.patientService = patientService;
    }



    @ControllerAdvice
    public class GlobalExceptionHandler {

        private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<Map<String, String>> handelValidationException(MethodArgumentNotValidException ex) {
            Map<String, String> errors = new HashMap<>();
            ex.getBindingResult().getFieldErrors().forEach(error -> errors.put(error.getField(), error.getDefaultMessage()));
            return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
        }

        @ExceptionHandler(EmailAlreadyExistsException.class)
        public ResponseEntity<Map<String,String>> handelEmailAlreadyExistsException(EmailAlreadyExistsException ex){

            log.warn("Email address already Exist ",ex.getMessage());
            Map<String, String> errors = new HashMap<>();
            errors.put("message","Email Already Exists");
            return ResponseEntity.badRequest().body(errors);
        }


        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
                String authorizationHeader = request.getHeader("Authorization");
                String username = null;
                String jwt = null;
                if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                    jwt = authorizationHeader.substring(7);
                    username = jwtUtil.extractUsername(jwt);
                }
                if (username != null) {
                    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                    if (jwtUtil.validateToken(jwt)) {
                        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                        auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(auth);
                    }
                }
                chain.doFilter(request, response);
// how to create a custom exception